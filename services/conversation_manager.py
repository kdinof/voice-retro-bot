"""Conversation flow manager for multi-step retrospective conversations."""

from __future__ import annotations
import asyncio
from datetime import datetime, timedelta, date
from typing import Optional, Dict, Any, Tuple

import structlog
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup

from models.conversation_state import ConversationState, RetroStep
from services.database_service import DatabaseService
from services.voice_processor import voice_processor
from services.text_processor import text_processor, RetroFieldType
from services.telegram_service import TelegramService


logger = structlog.get_logger()


class ConversationFlowError(Exception):
    """Raised when conversation flow encounters an error."""
    pass


class ConversationManager:
    """Manages multi-step retrospective conversations."""
    
    def __init__(self, database_service: DatabaseService, telegram_service: TelegramService):
        self.db = database_service
        self.telegram = telegram_service
        
        # Step configuration
        self.step_questions = {
            RetroStep.ENERGY: {
                "question": "üîã **–ö–∞–∫ —Ç–≤–æ–π —É—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏ —Å–µ–≥–æ–¥–Ω—è?**\n\n–û—Ü–µ–Ω–∏ –æ—Ç 1 –¥–æ 5:\n‚Ä¢ 1 - –û—á–µ–Ω—å –Ω–∏–∑–∫–∏–π\n‚Ä¢ 2 - –ù–∏–∑–∫–∏–π\n‚Ä¢ 3 - –°—Ä–µ–¥–Ω–∏–π\n‚Ä¢ 4 - –í—ã—Å–æ–∫–∏–π\n‚Ä¢ 5 - –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π",
                "hint": "üí° –û—Ç–ø—Ä–∞–≤—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ —Ü–∏—Ñ—Ä—É —Å –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ–º",
                "field_type": RetroFieldType.ENERGY
            },
            RetroStep.MOOD: {
                "question": "üòä **–ö–∞–∫–æ–µ —É —Ç–µ–±—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ?**\n\n–û–ø–∏—à–∏ —Å–≤–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏ —ç–º–æ—Ü–∏–∏ —Å–µ–≥–æ–¥–Ω—è",
                "hint": "üí° –ú–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç–º–æ–¥–∑–∏ –∏ —Ä–∞—Å—Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ –ø–æ–≤–ª–∏—è–ª–æ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ",
                "field_type": RetroFieldType.MOOD
            },
            RetroStep.WINS: {
                "question": "üèÜ **–ö–∞–∫–∏–µ —É —Ç–µ–±—è –ø–æ–±–µ–¥—ã —Å–µ–≥–æ–¥–Ω—è?**\n\n–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–≤–æ–∏—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö, –±–æ–ª—å—à–∏—Ö –∏ –º–∞–ª–µ–Ω—å–∫–∏—Ö",
                "hint": "üí° –ú–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–∞—è –∑–∞–¥–∞—á–∞, –Ω–æ–≤–æ–µ –∑–Ω–∞–Ω–∏–µ, –ø–æ–º–æ—â—å –¥—Ä—É–≥–∏–º...",
                "field_type": RetroFieldType.WINS
            },
            RetroStep.LEARNINGS: {
                "question": "üìö **–ß–µ–º—É —Ç—ã –Ω–∞—É—á–∏–ª—Å—è —Å–µ–≥–æ–¥–Ω—è?**\n\n–ö–∞–∫–∏–µ —É—Ä–æ–∫–∏ –∏–ª–∏ –∏–Ω—Å–∞–π—Ç—ã –ø–æ–ª—É—á–∏–ª?",
                "hint": "üí° –ù–æ–≤—ã–µ –∑–Ω–∞–Ω–∏—è, –ø–æ–Ω–∏–º–∞–Ω–∏—è, –≤—ã–≤–æ–¥—ã –∏–∑ –æ–ø—ã—Ç–∞...",
                "field_type": RetroFieldType.LEARNINGS
            },
            RetroStep.NEXT_ACTIONS: {
                "question": "üéØ **–ß—Ç–æ –ø–ª–∞–Ω–∏—Ä—É–µ—à—å –¥–µ–ª–∞—Ç—å –∑–∞–≤—Ç—Ä–∞?**\n\n–ö–∞–∫–∏–µ —É —Ç–µ–±—è –ø–ª–∞–Ω—ã –∏ –∑–∞–¥–∞—á–∏?",
                "hint": "üí° –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è, –≤—Å—Ç—Ä–µ—á–∏, –ø—Ä–æ–µ–∫—Ç—ã...",
                "field_type": RetroFieldType.NEXT_ACTIONS
            },
            RetroStep.MITS: {
                "question": "‚≠ê **–ö–∞–∫–∏–µ 1-3 —Å–∞–º—ã–µ –≤–∞–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∑–∞–≤—Ç—Ä–∞?**\n\n–í—ã–±–µ—Ä–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏ (MITs - Most Important Tasks)",
                "hint": "üí° –¢–µ –∑–∞–¥–∞—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–µ—Å—É—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–æ–ª—å–∑—É",
                "field_type": RetroFieldType.MITS
            },
            RetroStep.EXPERIMENT: {
                "question": "üß™ **–•–æ—á–µ—à—å –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —á—Ç–æ-—Ç–æ –Ω–æ–≤–æ–µ?**\n\n–ö–∞–∫–æ–π —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç –ø–ª–∞–Ω–∏—Ä—É–µ—à—å –ø—Ä–æ–≤–µ—Å—Ç–∏?",
                "hint": "üí° –ù–æ–≤—ã–π –ø–æ–¥—Ö–æ–¥, –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –ø—Ä–∏–≤—ã—á–∫–∞... –ú–æ–∂–µ—à—å –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
                "field_type": RetroFieldType.EXPERIMENT,
                "optional": True
            }
        }
        
        # Step progression order
        self.step_order = [
            RetroStep.ENERGY,
            RetroStep.MOOD,
            RetroStep.WINS,
            RetroStep.LEARNINGS,
            RetroStep.NEXT_ACTIONS,
            RetroStep.MITS,
            RetroStep.EXPERIMENT,
            RetroStep.REVIEW,
            RetroStep.COMPLETED
        ]
    
    async def start_retro_conversation(self, user_id: int, chat_id: int) -> bool:
        """
        Start a new retrospective conversation.
        
        Args:
            user_id: Telegram user ID
            chat_id: Chat ID
            
        Returns:
            True if conversation started successfully
        """
        try:
            async for session in self.db.get_session():
                repos = await self.db.get_repositories(session)
                
                # Check if user has an active conversation
                existing_state = await repos.conversations.get_by_user_id(user_id)
                if existing_state and existing_state.is_active:
                    await self.telegram.send_message_with_retry(
                        chat_id=chat_id,
                        text="üìù –£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤–∞!\n\n"
                             "–ü—Ä–æ–¥–æ–ª–∂–∏–º —Å —Ç–æ–≥–æ –º–µ—Å—Ç–∞, –≥–¥–µ –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å?"
                    )
                    await self._continue_conversation(user_id, chat_id)
                    return True
                
                # Get or create user
                user = await repos.users.create_or_update_from_telegram(
                    telegram_id=user_id
                )
                
                # Create new retro for today
                today = date.today()
                existing_retro = await repos.retros.get_by_user_and_date(user_id, today)
                
                if existing_retro and existing_retro.is_completed:
                    await self.telegram.send_message_with_retry(
                        chat_id=chat_id,
                        text="‚úÖ –¢—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—É –Ω–∞ —Å–µ–≥–æ–¥–Ω—è!\n\n"
                             "–•–æ—á–µ—à—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç?",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("üìÑ –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ—Ç—Ä–æ", callback_data=f"show_retro_{existing_retro.id}")]
                        ])
                    )
                    return True
                
                if not existing_retro:
                    retro = await repos.retros.create_daily_retro(user_id, today)
                else:
                    retro = existing_retro
                
                # Create conversation state
                await repos.conversations.create_or_update_state(
                    user_id=user_id,
                    step=RetroStep.ENERGY,
                    retro_id=retro.id,
                    timeout_minutes=30
                )
                
                await repos.commit()
                
                # Send welcome message and start first question
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text="üéØ **–ù–∞—á–∏–Ω–∞–µ–º —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—É!**\n\n"
                         f"–î–∞—Ç–∞: {today.strftime('%d.%m.%Y')}\n"
                         "–ü—Ä–æ–≥—Ä–µ—Å—Å: 1/7 —à–∞–≥–æ–≤\n\n"
                         "–û—Ç–≤–µ—á–∞–π –≥–æ–ª–æ—Å–æ–≤—ã–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –∏–ª–∏ —Ç–µ–∫—Å—Ç–æ–º. "
                         "–í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –º–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å /stop –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏.",
                    parse_mode="Markdown"
                )
                
                # Ask first question
                await self._ask_current_question(user_id, chat_id)
                
                logger.info("Started retro conversation", user_id=user_id, retro_id=retro.id)
                return True
        
        except Exception as e:
            logger.error("Failed to start retro conversation", user_id=user_id, error=str(e))
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—ã. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ."
            )
            return False
    
    async def handle_user_response(self, user_id: int, chat_id: int, message_text: str = "", voice_file_id: str = "") -> bool:
        """
        Handle user response in conversation flow.
        
        Args:
            user_id: Telegram user ID
            chat_id: Chat ID
            message_text: Text message from user
            voice_file_id: Voice message file ID
            
        Returns:
            True if response was processed successfully
        """
        try:
            async for session in self.db.get_session():
                repos = await self.db.get_repositories(session)
                
                # Get current conversation state
                state = await repos.conversations.get_by_user_id(user_id)
                if not state or not state.is_active:
                    await self.telegram.send_message_with_retry(
                        chat_id=chat_id,
                        text="‚ùì –£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—ã.\n\n"
                             "–ù–∞—á–Ω–∏ –Ω–æ–≤—É—é —Å –ø–æ–º–æ—â—å—é /retro"
                    )
                    return False
                
                # Check if conversation expired
                if state.is_expired:
                    await self._handle_expired_conversation(user_id, chat_id)
                    return False
                
                # Get user input (voice or text)
                if voice_file_id:
                    user_input = await self._process_voice_input(voice_file_id, chat_id)
                    if not user_input:
                        return False
                else:
                    user_input = message_text.strip()
                
                if not user_input:
                    await self.telegram.send_message_with_retry(
                        chat_id=chat_id,
                        text="ü§î –ù–µ –º–æ–≥—É –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑!"
                    )
                    return False
                
                # Process response for current step
                await self._process_step_response(user_id, chat_id, state, user_input)
                
                return True
        
        except Exception as e:
            logger.error("Failed to handle user response", user_id=user_id, error=str(e))
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–≤–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑."
            )
            return False
    
    async def stop_conversation(self, user_id: int, chat_id: int) -> bool:
        """
        Stop current conversation.
        
        Args:
            user_id: Telegram user ID
            chat_id: Chat ID
            
        Returns:
            True if conversation was stopped
        """
        try:
            async for session in self.db.get_session():
                repos = await self.db.get_repositories(session)
                
                state = await repos.conversations.get_by_user_id(user_id)
                if not state or not state.is_active:
                    await self.telegram.send_message_with_retry(
                        chat_id=chat_id,
                        text="‚ÑπÔ∏è –£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—ã."
                    )
                    return False
                
                # Reset conversation state
                await repos.conversations.reset_conversation(user_id)
                await repos.commit()
                
                # Get current progress
                progress = self._get_step_progress(state.current_step)
                
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"‚è∏Ô∏è **–†–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞**\n\n"
                         f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {progress[0]}/{progress[1]} —à–∞–≥–æ–≤\n\n"
                         "–¢—ã –º–æ–∂–µ—à—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–∑–∂–µ —Å –ø–æ–º–æ—â—å—é /retro",
                    parse_mode="Markdown"
                )
                
                logger.info("Stopped conversation", user_id=user_id, step=state.current_step)
                return True
        
        except Exception as e:
            logger.error("Failed to stop conversation", user_id=user_id, error=str(e))
            return False
    
    async def _continue_conversation(self, user_id: int, chat_id: int):
        """Continue existing conversation."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            state = await repos.conversations.get_by_user_id(user_id)
            if state and state.is_active:
                progress = self._get_step_progress(state.current_step)
                
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"üìù **–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—É**\n\n"
                         f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {progress[0]}/{progress[1]} —à–∞–≥–æ–≤\n\n"
                         "–û—Ç–≤–µ—á–∞–µ–º –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å:",
                    parse_mode="Markdown"
                )
                
                await self._ask_current_question(user_id, chat_id)
    
    async def _ask_current_question(self, user_id: int, chat_id: int):
        """Ask current question based on conversation state."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            state = await repos.conversations.get_by_user_id(user_id)
            if not state:
                return
            
            if state.current_step == RetroStep.REVIEW:
                await self._show_retro_review(user_id, chat_id)
                return
            
            if state.current_step == RetroStep.COMPLETED:
                await self._complete_retro(user_id, chat_id)
                return
            
            step_config = self.step_questions.get(state.current_step)
            if not step_config:
                logger.error("Unknown step", step=state.current_step)
                return
            
            progress = self._get_step_progress(state.current_step)
            
            # Create skip button for optional questions
            keyboard = None
            if step_config.get("optional"):
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_step")]
                ])
            
            message_text = (
                f"**–®–∞–≥ {progress[0]}/{progress[1]}**\n\n"
                f"{step_config['question']}\n\n"
                f"{step_config['hint']}"
            )
            
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text=message_text,
                parse_mode="Markdown",
                reply_markup=keyboard
            )
    
    async def _process_voice_input(self, voice_file_id: str, chat_id: int) -> Optional[str]:
        """Process voice input and return transcribed text."""
        try:
            # Process voice message
            result = await voice_processor.process_telegram_voice(
                bot=self.telegram.bot,
                file_id=voice_file_id,
                chat_id=chat_id,
                language="ru"
            )
            
            if result.success:
                return result.transcribed_text
            else:
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"‚ùå {result.error_message}\n\n–ü–æ–ø—Ä–æ–±—É–π –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–º."
                )
                return None
        
        except Exception as e:
            logger.error("Voice processing failed", error=str(e))
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text="‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–º."
            )
            return None
    
    async def _process_step_response(self, user_id: int, chat_id: int, state: ConversationState, user_input: str):
        """Process user response for current step."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            step_config = self.step_questions.get(state.current_step)
            if not step_config:
                return
            
            field_type = step_config["field_type"]
            
            # Process input with GPT
            processing_result = await text_processor.process_retro_field(
                field_type=field_type,
                user_input=user_input
            )
            
            if processing_result.success:
                # Save processed data to retro
                await self._save_field_data(repos, state.current_retro_id, field_type, processing_result.processed_data)
                
                # Show confirmation
                summary = text_processor.get_field_summary(processing_result, field_type)
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"‚úÖ {summary}\n\n_–ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É..._",
                    parse_mode="Markdown"
                )
                
                # Move to next step
                await self._advance_conversation_step(user_id, chat_id, state)
            
            else:
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç: {processing_result.error_message}\n\n"
                         "–ü–æ–ø—Ä–æ–±—É–π –æ—Ç–≤–µ—Ç–∏—Ç—å –ø–æ-–¥—Ä—É–≥–æ–º—É."
                )
    
    async def _save_field_data(self, repos, retro_id: int, field_type: RetroFieldType, processed_data: Dict[str, Any]):
        """Save processed field data to retro."""
        if field_type == RetroFieldType.ENERGY:
            energy_data = processed_data.get("energy_data", {})
            await repos.retros.update_retro_field(retro_id, "energy_level", energy_data.get("energy_level"))
            if energy_data.get("explanation"):
                await repos.retros.set_temp_data(retro_id, "energy_explanation", energy_data["explanation"])
        
        elif field_type == RetroFieldType.MOOD:
            mood_data = processed_data.get("mood_data", {})
            await repos.retros.update_retro_field(retro_id, "mood", mood_data.get("mood_emoji"))
            await repos.retros.update_retro_field(retro_id, "mood_explanation", mood_data.get("mood_explanation"))
        
        elif field_type == RetroFieldType.WINS:
            wins_list = processed_data.get("wins_list", [])
            await repos.retros.update_retro_field(retro_id, "wins", wins_list)
        
        elif field_type == RetroFieldType.LEARNINGS:
            learnings_list = processed_data.get("learnings_list", [])
            await repos.retros.update_retro_field(retro_id, "learnings", learnings_list)
        
        elif field_type == RetroFieldType.NEXT_ACTIONS:
            actions_list = processed_data.get("next_actions_list", [])
            await repos.retros.update_retro_field(retro_id, "next_actions", actions_list)
        
        elif field_type == RetroFieldType.MITS:
            mits_list = processed_data.get("mits_list", [])
            await repos.retros.update_retro_field(retro_id, "mits", mits_list)
        
        elif field_type == RetroFieldType.EXPERIMENT:
            experiment_data = processed_data.get("experiment_data", {})
            await repos.retros.update_retro_field(retro_id, "experiment", experiment_data)
        
        await repos.commit()
    
    async def _advance_conversation_step(self, user_id: int, chat_id: int, state: ConversationState):
        """Advance to next conversation step."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            # Get next step
            next_step = self._get_next_step(state.current_step)
            
            if next_step:
                # Update conversation state
                await repos.conversations.update_step(user_id, next_step)
                await repos.commit()
                
                # Small delay before next question
                await asyncio.sleep(1)
                
                # Ask next question
                await self._ask_current_question(user_id, chat_id)
            else:
                # Conversation complete
                await self._complete_retro(user_id, chat_id)
    
    async def _show_retro_review(self, user_id: int, chat_id: int):
        """Show retro review before completion."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            state = await repos.conversations.get_by_user_id(user_id)
            if not state:
                return
            
            retro = await repos.retros.get_by_id(state.current_retro_id)
            if not retro:
                return
            
            # Generate preview
            markdown = retro.to_markdown()
            
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text="üìã **–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—ã:**",
                parse_mode="Markdown"
            )
            
            # Send markdown (split if too long)
            if len(markdown) > 4000:
                parts = [markdown[i:i+4000] for i in range(0, len(markdown), 4000)]
                for part in parts:
                    await self.telegram.send_message_with_retry(
                        chat_id=chat_id,
                        text=f"```markdown\n{part}\n```",
                        parse_mode="Markdown"
                    )
            else:
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"```markdown\n{markdown}\n```",
                    parse_mode="Markdown"
                )
            
            # Ask for confirmation
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="complete_retro")],
                [InlineKeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_retro")]
            ])
            
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text="–í—Å–µ –≤–µ—Ä–Ω–æ? –ú–æ–∂–µ–º –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—É!",
                reply_markup=keyboard
            )
    
    async def _complete_retro(self, user_id: int, chat_id: int):
        """Complete the retrospective."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            state = await repos.conversations.get_by_user_id(user_id)
            if not state:
                return
            
            # Complete retro
            retro = await repos.retros.complete_retro(state.current_retro_id)
            
            # Reset conversation
            await repos.conversations.reset_conversation(user_id)
            await repos.commit()
            
            if retro:
                # Send completion message
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text="üéâ **–†–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!**\n\n"
                         f"–î–∞—Ç–∞: {retro.date.strftime('%d.%m.%Y')}\n"
                         f"–ó–∞–ø–æ–ª–Ω–µ–Ω–æ: {retro.completion_percentage:.0f}%\n\n"
                         "–£–≤–∏–¥–∏–º—Å—è –∑–∞–≤—Ç—Ä–∞ –¥–ª—è –Ω–æ–≤–æ–π —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—ã! üòä",
                    parse_mode="Markdown"
                )
                
                # Send final document
                markdown = retro.to_markdown()
                await self.telegram.send_message_with_retry(
                    chat_id=chat_id,
                    text=f"üìÑ **–¢–≤–æ—è —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤–∞:**\n\n```markdown\n{markdown}\n```",
                    parse_mode="Markdown"
                )
                
                logger.info("Completed retro", user_id=user_id, retro_id=retro.id)
    
    async def _handle_expired_conversation(self, user_id: int, chat_id: int):
        """Handle expired conversation."""
        async for session in self.db.get_session():
            repos = await self.db.get_repositories(session)
            
            await repos.conversations.reset_conversation(user_id)
            await repos.commit()
            
            await self.telegram.send_message_with_retry(
                chat_id=chat_id,
                text="‚è∞ –í—Ä–µ–º—è —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—ã –∏—Å—Ç–µ–∫–ª–æ (30 –º–∏–Ω—É—Ç –±–µ–∑–¥–µ–π—Å—Ç–≤–∏—è).\n\n"
                     "–ù–∞—á–Ω–∏ –Ω–æ–≤—É—é —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤—É —Å –ø–æ–º–æ—â—å—é /retro"
            )
    
    def _get_next_step(self, current_step: RetroStep) -> Optional[RetroStep]:
        """Get next step in conversation flow."""
        try:
            current_index = self.step_order.index(current_step)
            if current_index < len(self.step_order) - 1:
                return self.step_order[current_index + 1]
        except ValueError:
            pass
        return None
    
    def _get_step_progress(self, current_step: RetroStep) -> Tuple[int, int]:
        """Get current step progress."""
        try:
            current_index = self.step_order.index(current_step)
            return (current_index + 1, len(self.step_order) - 2)  # Exclude REVIEW and COMPLETED
        except ValueError:
            return (1, 7)


# Service will be instantiated in telegram service with dependencies